# 第九周 RPC	

## 1. RPC的概念

RPC远程过程调用，“像调用本地方法一样调用远程方法”。

在微服务中，服务之间的调用属于远程调用，为了方便系统之间的调用，rpc孕育而生。

RPC的原理图

<img src="/Users/lijiajun/Library/Application Support/typora-user-images/image-20201216155700609.png" alt="image-20201216155700609" style="zoom:50%;" />

可以看到，Java中的RMI就是一种rpc，核心就是代理机制。

本地通过调用代理类来访问远程方法，远程方法根据方法签名（哪个类，哪个方法，参数如何）来执行相应的方法。

* 所以这里代理类需要实现网络通信，因为他需要访问远端，这里面必要要序列化与反序列化。

* 远端有一个自己的注册表，里面注册了各个实现类，用来执行具体的逻辑。因此远端需要根据传入的参数来找到具体的实现类。



这里面的重要的点：

1. 如何实现本地代理

   实现一个代理类有很多方式：

   * Java动态代理：Proxy.newInstance
   * 字节码增强：ByteBuddy，ASM等

2. 通讯方式
   * Http：OkHttpClient，netty等
   * Tcp: Socket，netty等。

3. 序列化
   * 二进制：
   * Json：Jackson

4. 服务器如何找到实现类

   这个根据业务而定，其核心就是维护一个context的注册表，类似Spring的Bean容器。



如果是分布式环境，会遇到什么问题？

也就是远端服务可能有多个节点，比如本地调用远端的OrderServce（假如有2个节点）。这里面需要解决两个问题。

  1. 本地如何发现远端服务，如何寻址的问题（比如feign中是通过http传入url来找到服务）。

     这里本地发现远端服务，需要满足：远端条件必然可用，而不是不可访问或是访问异常的。那么必定需要一个第三方来管理这些服务，使服务之间可以相互之间可见，同时还能知道各个服务是否健康。那么这个第三方就是我们的Zookeeper，称为服务注册中心。

  2. 如何决定是调用OrderService1还是OrderService2

     这里我的理解可能有两种方式：一种是客户端采取负载均衡策略决定调用哪个OrderService，但这种方式需要客户端维护一个服务列表，类似于Spring Cloud Robbin；第二种交给服务注册中心来决定，服务注册中心根据自己的策略来随机或者轮训选择健康的服务。这样的好处是客户端不需要维护调用列表，但坏处就是使注册中心承担了消息的转发，需要吸收转发过来的网络流量，使其职责不单一。	

## 2. Dubbo原理

后面有时间再补充。



## 3. 作业

### 1. 改造自定义 RPC 的程序，提交到 GitHub：

- 尝试将服务端写死查找接口实现类变成泛型和反射；
- 尝试将客户端动态代理改成 AOP，添加异常处理；
- 尝试使用 Netty+HTTP 作为 client 端传输方式。

见代码，回头补文档。
